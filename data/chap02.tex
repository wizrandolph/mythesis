\chapter{FRET双杂交分析数据处理软件（Fretha）的设计和开发}

\section{引言}

\ifshowtext
在现代生物医学研究中，FRET双杂交分析作为一种关键技术，用于检测生物分子间的相互作用，为揭示生物过程的分子机制提供了重要手段。然而，传统的 FRET 双杂交分析数据处理过程繁琐且效率低下，严重依赖人工操作，容易引入误差。开发专门针对 FRET 双杂交分析数据处理的配套软件，能够实现数据的自动化采集、标准化处理以及高效的分析统计，对于提升研究效率和准确性具有重要意义。
本章节首先根据我们组自研的用于高通量药物筛选的 FRET 显微成像系统（FRETscopeII）的硬件参数和 FRET 数据处理及 FRET 双杂交分析数据处理功能进行深入的需求分析。基于此需求分析，对软件按照功能进行科学合理的模块划分和总体框架设计。接着，详细介绍软件的开发技术选型以及每个模块的具体实现方式，旨在全面展示 Fretha 软件从设计构思到开发实现的全过程。
\fi

\section{需求分析和总体设计}

\subsection{需求分析}

\ifshowtext
% FRET多模态显微成像系统（FRETscopeII）的硬件和数据特点；
FRETscopeII是本课题组自研的适用于$3^3$-FRET、E-FRET、Pb-FRET等多种定量FRET分析方法的FRET多模态显微成像系统。该系统具备高分辨率成像、多通道同步采集等先进特性，能够获取高质量的 FRET 三通道图像数据。

% FRET双杂交分析数据处理流程。
使用FRETscopeII对制备好的样本进行图像采集得到若干视野的FRET三通道图像后，通过FRET双杂交分析方法定量计算细胞中的结合比等信息需要如下分析步骤：首先需要对FRET数据进行数据完整性校验，确保每个视野下存在完整的三通道图像和文件完整可读，然后对每个视野进行荧光信号提取，通过在图像上绘制ROI并计算其灰度均值作为FRET分析计算重要的荧光信号；根据E-FRET和$3^3$-FRET方法将上述荧光信号代入对应的计算公式求取$E_A$、$E_D$、$R_C$等FRET数据；对这些数据进一步依据物理含义或者数据分析进行异常值去除等数据预处理；最后是通过优化算法拟合Langmiur模型或者线性模型计算相关的参数。具体流程如图\ref{fig:tha_data_process}所示。

\begin{figure}[hbtp]
    \centering
    \includegraphics[width=1\linewidth]{../figures/2/2_FRET双杂交分析数据处理流程.png}
    \caption{FRET双杂交分析数据处理流程}
    \label{fig:tha_data_process}
\end{figure}

\fi

\subsection{模块划分}

结合 FRET 双杂交分析的数据处理流程与功能逻辑，Fretha 软件主要划分为以下核心模块：
成像参数设置模块：负责设置 FRET 成像过程中的关键参数，确保成像数据的准确性和一致性。
数据完备性检验模块：对输入数据进行严格的完整性和合法性检验，避免异常数据导致的分析错误。
FRET 图像处理模块：支持手动图像处理和 ROI 选取，满足用户对数据的精细化处理需求。
自动 ROI 圈点模块：结合LURS算法实现自动 ROI 选取，显著提高数据处理效率。
结果可视化模块：将分析结果以直观的图表形式展示，并提供数据保存功能，方便用户进一步分析和应用。

\subsection{软件总体框架}

Fretha架构采用分层设计，由顶层向下依次分别为：表现层、业务层、数据访问层和数据层，如图\ref{fig:fretha_arch}所示。

\begin{figure}[hbtp]
    \centering
    \includegraphics[width=1\linewidth]{../figures/2/2_Fretha软件架构图.png}
    \caption{Fretha软件总体架构}
    \label{fig:fretha_arch}
\end{figure}

表现层处于整个架构的最外层，直接面向用户，是用户与系统进行交互的主要界面。
它负责接收用户输入的各种指令和数据，并以直观、友好的方式展示系统的处理结果。
Fretha的表现层主要包括参数设置界面、图像处理界面、ROI圈点界面、数据记录界面、可视化界面等，用户能够轻松地与系统进行交互，完成FRET双杂交分析的数据处理操作。

业务层是整个架构的核心逻辑处理部分，承担着对系统业务规则和流程的实现。
它接收来自表现层的请求，根据预设的业务逻辑对数据进行处理和转换。
Fretha的业务层封装了包括参数读/写业务、数据完备性检验业务、自动ROI选取业务、数据导入/导出业务、FRET双杂交分析业务、数据绘图/可视化业务等。
FRET定量计算器和FRET图像分析业务是业务层中进行FRET定量计算的业务，分别可以对FRET原始灰度数据和FRET图像数据进行定量FRET计算分析。Fretha中这两个业务为其他业务提供了关于FRET定量计算的数据处理能力，使得FRET定量分析及FRET双杂交分析数据处理过程中的科学计算逻辑进一步独立，减少了软件架构的冗余度，提高了编码以及程序运行的效率。

数据访问层实现对数据的访问和操作，它将业务层与数据层进行隔离。
数据访问层提供了统一的数据访问接口，业务层通过调用这些接口来获取和存储数据，而无需关心数据的具体存储方式和位置。
通过设置数据访问层，能够使得在复杂的业务处理时避免对数据的直接操作和影响，从而提高了数据存储的安全性。
Fretha的数据访问包括FRET图像数据访问、FRET数值数据访问和FRET双杂交数据访问的接口。

最后是数据层，作为架构的最底层，数据层负责存储系统的所有数据。
Fretha数据层包括系统静态数据、FretImage类、FretDataPiece类和FretRecord类。
系统静态数据是在软件运行时的环境参数，只需要在指定步骤运行前提前设置好即可，如成像参数、文件目录等。
FretImage类、FretDataPiece类和FretRecord类用来表示数据处理时的各种动态数据。
在FRET双杂交分析数据处理中，一组FRET三通道图像中可以提取并计算出若干条FRET数据，由若干条FRET数据作为一个批次只能解析出一条FRET双杂交分析结果。
因此，在设计上三种数据实体类型存在关联关系，FretImage和FretDataPiece之间存在一对多的关系，FretDataPiece和FretRecord之间存在一对多关系，如图\ref{fig:fretha_data_relations}所示。

\begin{figure}[hbtp]
    \centering
    \includegraphics[width=1\linewidth]{../figures/2/2_Fretha数据层对应关系.png}
    \caption{Fretha数据层实体关联关系图}
    \label{fig:fretha_data_relations}
\end{figure}

\subsection{开发技术选型}
\ifshowtext
Qt 5.15.2是Qt官方发布的长期支持（LTS）版本，具有卓越的跨平台性能。该版本能够在Windows、Linux、macOS以及嵌入式系统等多种平台上稳定运行。
开发者只需对一套代码进行简单配置，即可实现不同平台的适配，这种特性大幅降低了软件开发与维护的成本。FRETscopeII的控制软件系统选择了Qt 5.15.2版本作为技术选型。
为了确保Fretha和FRETscopeII在开发过程中的一致性和可融合性，Fretha同样选用该版本作为软件开发的基础技术。
这一选择不仅有利于代码的共享、复用和维护，还能显著降低二次开发以及未来合并开发过程中的成本和风险。

在计算机视觉处理方面，Fretha选用了OpenCV（Open Source Computer Vision Library）。
OpenCV是一个开源的计算机视觉与机器学习软件库，具备强大的跨平台能力，可在Windows、Linux、macOS、Android、iOS等多种操作系统上运行。
其功能丰富多样，广泛涵盖了图像和视频处理的各个方面，例如图像的读取、滤波、边缘检测等。
在性能上，OpenCV经过SIMD指令集优化以及多线程并行计算等技术的优化，处理效率得到了显著提升，能够充分满足实时性的需求。
此外，OpenCV拥有一个活跃的社区，汇聚了大量的开发者。
社区中提供了丰富的算法、示例代码和实际案例，为开发者提供了有力的技术支持和学习借鉴的资源。
基于以上诸多优势，OpenCV完全契合本项目中计算机视觉任务的需求，因此被选定为本项目的重要技术工具。

在最优化计算方面，Fretha选择了C++库Dlib。
Dlib库集成了基于梯度的优化算法，并采用了自适应学习率机制，能够实现快速且稳定的收敛，有效降低了陷入局部最优解的概率。
该库还采用了牛顿法与拟牛顿法，在保证计算精度的同时兼顾了计算效率，能够显著缩短大规模训练所需的时间。
此外，Dlib在处理约束优化问题方面表现出色，例如可以运用内点法来解决资源分配中的约束难题，为研究工作提供了可靠的支持。  
\fi

\section{Fretha的开发实现}

\subsection{成像参数设置模块}
\ifshowtext
FRET定量分析中，测量并设置成像过程时的成像参数至关重要。Fretha作为离线数据处理软件，在数据处理前需要设置好FRET定量计算过程中必须的参数。

FRET成像参数在Fretha中以静态参数保存在软件内存中，是数据处理时的环境参数。其中，$a$、$b$、$c$、$d$、$G$、$k$和$Y$是FRET成像系统的光学参数，在前文中已介绍；$ExpTimeAA$、$ExpTimeDD$和$ExpTimeDA$是成像时三个探测通道的曝光时间，在FRET定量计算时需要根据曝光时间参数在各个通道归一化，然后才能进行计算。Fretha中包括的所有成像参数如表\ref{tab:fretha_param_list}所示。

\begin{table}[htb]
  \centering
  \caption[FRET成像参数]{FRET成像参数}
  \label{tab:fretha_param_list}
    \begin{tabular*}{\textwidth}{cp{8cm}lc} % 修改第二列格式为p{6cm}，可根据实际情况调整宽度
      \toprule[1.5pt]
      {\hei 参数名} & {\hei 参数意义} & {\hei 典型范围} & {\hei 单位} \\
      \hline
      $a$ & 供体激发时在DA通道的串扰系数 & $(0,1)$ & 无\\
      $b$ & 所有的一切都在这里面。 & $(0,1)$ & 无\\
      $c$ & 模板类文件。 & $(0,1)$ & 无\\
      $d$ & 受体激发时在DA通道的串扰系数 & $(0,1)$ & 无\\
      $G$ & 供体猝灭和受体荧光增强的比值         & $(0,+\infty)$ & 无\\
      $k$ & 受体浓度和供体浓度相同时的荧光比值 & $(0,+\infty)$ & 无\\
      $Y$ & 供受体在激发光条件下的消光系数之比，也记作$\varepsilon_{YFP}(\lambda)/\varepsilon_{CFP}(\lambda)$   & $(0,+\infty)$ & 无\\
      $ExpTimeAA$ & AA通道下的成像曝光时间 & $(0,+\infty)$ & 毫秒（ms）\\
      $ExpTimeDD$ & DD通道下的成像曝光时间 & $(0,+\infty)$ & 毫秒（ms）\\
      $ExpTimeDA$ & DA通道下的成像曝光时间 & $(0,+\infty)$ & 毫秒（ms）\\
      \bottomrule[1.5pt]
    \end{tabular*}
\end{table}

成像参数设置模块在业务设计上遵循以下原则：
（1）设置时所有参数应一同更新；
（2）每个参数需要在其有意义的范围内，避免无意义的值。
具体来说，在点击“更新参数”按钮时，若无法从界面中的每个参数输入框都解析到合法的数字，那么本次更新参数就会失败。
这是因为FRET成像参数是一批参数，参数间存在依赖关系，如测量参数$G$、$k$、$Y$就依赖参数$a$、$b$、$c$、$d$，这是因为测定参数$G$、$k$、$Y$时需要计算敏化发射荧光$F_C$，根据公式\ref{eq:fc}所示，$F_C$的确定与$a$、$b$、$c$、$d$密切相关。
强制所有参数一同更新可以避免用户单独设置某一参数而导致参数之间不匹配等问题。

FRET成像参数一般比较稳定，一般2到3个月才需要重新测量，因此需要持久化到本地，以供多次处理数据时使用。
Fretha的本地参数文件保存为可执行程序同级目录下的“config.ini”中。在软件初始化阶段，会自动检测并应用本地配置文件中的参数。
因此，用户可通过保存多套配置文件，在使用时替换目标配置文件，快速进行参数配置的切换。

参数设置的业务流程如图\ref{fig:fretha_param_module_flow}所示。

\begin{figure}[hbtp]
    \centering
    \includegraphics[height=1\linewidth]{../figures/2/2_成像参数设置模块业务流程.drawio.png}
    \caption{参数设置模块业务流程图}
    \label{fig:fretha_param_module_flow}
\end{figure}
\fi

\subsection{数据完备性检验模块}

FRET双杂交分析需要处理一批FRET图像文件，因此需要对输入数据的完备性进行检验识别。
该模块的作用有以下两个方面：一方面通过模式识别FRET合法数据，避免了异常输入导致的运行错误；
另一方面，在这一模块会将FRET批数据的视野子文件夹进行解析和类型识别，为后续数据处理提供对子文件夹的不同操作。

Fretha的数据识别检验模块匹配识别FRETscopeII的数据格式，从而保证数据处理能够正常开始。
FRETscopeII的数据结构由上层到下层依次为：（1）批数据根目录；（2）视野子目录；（3）图片数据和参数文件。
其结构如图\ref{fig:fretscope_data_struct}所示。

\begin{figure}[htbp]
    \centering
    \includegraphics[height=0.5\linewidth]{../figures/2/2_FRETscopeII数据格式.drawio.png}
    \caption{FRETscopeII数据文件层级结构树形图}
    \label{fig:fretscope_data_struct}
\end{figure}

数据完备性检验业务的流程如图\ref{fig:fretha_data_check_flow}所示。
其中，检查子文件夹类型是通过图\ref{fig:fretscope_data_struct}进行匹配的，当且仅当子文件夹中同时存在“DA.tif”、“DD.tif”和“AA.tif”图片文件时，当前子文件夹会被识别为FRET视野，并在视野表格模型中记录。
其他情况的子文件夹会被记作“Unknown”文件夹，在后续FRET图像处理或者自动处理中被跳过。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\linewidth]{../figures/2/2_数据完备性检验业务.drawio.png}
    \caption{Fretha数据完备性检验业务主流程图}
    \label{fig:fretha_data_check_flow}
\end{figure}

\subsection{FRET图像处理模块}

FRET图像处理模块是对FRET三通道图像进行ROI提取等图像处理分析的模块，包括手动ROI圈点和自动ROI圈点等。其界面如图\ref{fig:fretha_imageprocess_ui}所示：

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.75\linewidth]{../figures/2/2_图像处理模块界面.png}
    \caption{Fretha图像处理模块界面示意图}
    \label{fig:fretha_imageprocess_ui}
\end{figure}

在FRET图像处理工作里，手动选取感兴趣区域ROI是一个基础且关键的操作，它能帮助分析人员聚焦于特定区域，进行更精确的数据处理与分析。为达成图像处理过程中 ROI 的手动选取功能，Fretha 借助 Qt 框架提供的 QGraphicsView 类，开发了自定义的 FretGraphicsView 类。QGraphicsView 是 Qt 用于可视化和交互处理二维图形场景的重要类，具备丰富的功能和良好的可扩展性，为 FretGraphicsView 的实现提供了有力支撑。

FretGraphicsView 类主要用于支持复杂的 ROI 编辑操作。该类中新增了一个 ROI 成员，这一设计使 FretGraphicsView 具备了更完善的 ROI 管理能力。它能够在视图中直观呈现 ROI 的大小和位置，方便用户确认所选区域。同时，通过状态栏更新 ROI 内的数据，并为用户提供具有参考意义的FRET信息，有助于用户更深入地理解图像数据。

在交互机制上FretGraphicsView通过自定义鼠标释放事件的信号，实现了与数据访问层的数据交互。当用户完成 ROI 选取并释放鼠标时FretGraphicsView 会将 ROI 的坐标和大小信息传递给数据访问层。数据访问层依据当前视野索引，从数据模型中读取相应的灰度数据。随后，这些灰度数据会被输送至 FretCalculator 进行定量 FRET 计算。计算完成后，原始灰度数据和 FRET 数据会更新到界面上，方便用户获取处理结果，为后续的数据分析工作提供依据。这种基于 QGraphicsView 扩展的设计，有效提升了 ROI 选取的灵活性和准确性，实现了图像处理与数据计算的有机结合，为图像处理应用开发提供了一种可行的技术方案。 

Fretha的状态栏中提供了视图类型切换选项，在数据处理中可以辅助圈点，主要包括归一化增强图，和FRET伪彩图两类，支持的视图类型如表\ref{tab:fretha_viewtype_list}所示。
\begin{table}[htbp]
  \centering
  \caption[FRET图像视图类型]{FRET图像视图类型表}
  \label{tab:fretha_viewtype_list}
    \begin{tabularx}{\linewidth}{
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X} % 修改第二列格式为p{6cm}，可根据实际情况调整宽度
      \toprule[1.5pt]
      {\hei 信息} & {\hei 说明} \\
      \hline
      Channel Merged & 三通道归一合成图 \\
      DD Normalized & DD通道的归一化增强图 \\
      DA Normalized & DA通道的归一化增强图 \\
      AA Normalized & AA通道的归一化增强图 \\
      $R_C$ Pseudo & $R_C$逐像素数值伪彩图 \\
      $E_D$ Pseudo & $E_D$逐像素数值伪彩图 \\
      \bottomrule[1.5pt]
    \end{tabularx}
\end{table}
归一化增强图包括DD、DA、AA通道分别归一化的增强视图以及三通道归一化合成图。FRET三通道原始图片由于测量系统的灰度量程为0至65535，在计算机显示时，灰度为65536的像素显示为纯白色，灰度为0的像素显示为纯黑。然而，FRET信号往往达不到量程的最大值，因此图片会显得灰暗，无法识别到图像中的细胞等问题。图像增强的计算公式如公式\ref{eq:normalize}所示。
\begin{equation}
\label{eq:normalize}
y = \frac{x - min_{old}}{max_{old}-min_{old}} \times (max_{new}-min_{new}) + min_{new}.
\end{equation}
其中，$x$是原图像中的像素值，$y$是经过归一化处理后的像素值，${min}_{old}$和${max}_{old}$分别是原图中像素灰度值的最小值和最大值，${min}_{new}$和${max}_{new}$分别是目标像素值中像素灰度值的最小值和最大值。在图像显示时，我们将其设置为易于观察的0\~255，因此公式\ref{eq:normalize}实际计算为：
\begin{equation}
\label{eq:normalize_255}
y = \frac{x - min_{old}}{max_{old}-min_{old}} \times 255
\end{equation}
除了视图辅助，Fretha状态栏能够清晰展示当前视野及ROI的状态信息，如当前视野的三通道背景灰度值、ROI信号的三通道信号背景比等，还可以显示使用当前ROI提供的扣除背景灰度值后的$I_{DD}$、$I_{DA}$和$I_{DD}$。Fretha状态栏的所有显示内容如表\ref{tab:fret_statusbar_list}所示。
当对ROI调整完毕后，点击“添加数据”可以将ROI内的数据记录到软件右侧的表格中。
\begin{table}[htbp]
  \centering
  \caption[FRET圈点状态栏显示内容]{FRET圈点状态栏显示内容}
  \label{tab:fret_statusbar_list}
        \begin{tabularx}{\linewidth}{
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X} % 修改第二列格式为p{6cm}，可根据实际情况调整宽度
      \toprule[1.5pt]
      {\hei 信息} & {\hei 说明} \\
      \hline
      AA信号 & AA通道的ROI内灰度均值 \\
      DA信号 & DA通道的ROI内灰度均值 \\
      DD信号 & DD通道的ROI内灰度均值 \\
      AA背景 & AA通道的视野背景灰度值 \\
      DA背景 & DA通道的视野背景灰度值 \\
      DD背景 & DD通道的视野背景灰度值 \\
      \bottomrule[1.5pt]
    \end{tabularx}
\end{table}
点击左侧“自动圈点”按钮，可以使用LURS算法进行自动ROI圈点，并记录到右侧的数据记录表中。自动圈点功能通过FRET双杂交求解器中封装的多线程服务，在不影响Fretha前台界面显示和操作的前提下，实现了一键式线程分离的自动数据处理。自动ROI圈点模块的业务流程及架构如图\ref{fig:fret_auto_roi_flow}所示。
架构层内的流程流转以实线表示，不同架构层之间的流程流转以虚线表示。
在实现自动圈点功能的流程转移中，发生在架构不同层之间的转移占更多数，而层内的流程转移相对较少，分层架构设计使得每个层内实现较好的封装，因此能够在实现复杂业务功能时，只需要专注于层和层之间的数据和流程切换即可。图中关于LURS算法和自动ROI圈点的算法原理将会在第三章具体说明。
\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\linewidth]{../figures/2/2_自动ROI圈点模块业务流程.drawio.png}
    \caption{Fretha自动圈点模块流程图}
    \label{fig:fret_auto_roi_flow}
\end{figure}

\subsection{数据控制模块}

数据控制模块支持对数据的实时操作，可以对于图像处理模块获得的数据，进行异常数据筛选、数据导入、数据导出、数据追踪、计算入口等数据控制功能。

在数据模型上，我们将一条数据类型FretDataPiece定义为：

\begin{table}[htbp]
  \centering
  \caption{FretDataPiece数据类型}
  \label{tab:数据项内容定义}
    \begin{tabularx}{\linewidth}{
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X
    >{\centering\arraybackslash}X} 
      \toprule[1.5pt]
      {\hei 信息} & {\hei 说明} \\
      \hline
      $I_{DD}$ & ROI在DD通道扣除背景后的信号强度 \\
      $I_{DA}$ & ROI在DA通道扣除背景后的信号强度 \\
      $I_{AA}$ & ROI在DD通道扣除背景后的信号强度 \\
      $E_D$ & 根据$I_{DD}$、$I_{DA}$、$I_{AA}$计算的$E_D$ \\
      $R_C$ & 根据$I_{DD}$、$I_{DA}$、$I_{AA}$计算的$R_C$ \\
      $E_A$ & 根据$I_{DD}$、$I_{DA}$、$I_{AA}$计算的$E_A$ \\
      $1/R_C$ & 根据$I_{DD}$、$I_{DA}$、$I_{AA}$计算的$1/R_C$ \\
      $x$ & ROI的横坐标 \\
      $y$ & ROI的纵坐标 \\
      $w$ & ROI的宽度 \\
      $h$ & ROI的高度 \\
      $view$ & ROI隶属的视野\\
      \bottomrule[1.5pt]
    \end{tabularx}
\end{table}

异常数据筛选分为两个阶段：
\begin{enumerate}
    \item 物理意义筛选。根据数据项的物理属性设定合理定义域。例如，$I_{DD}$应满足 $I_{DD} > 0$。对于数值型数据$X_i$，删除条件可表示为：
    \begin{equation}
    \text{删除条件} = \begin{cases} 
      1, & \text{若} \ x_i \notin [L_i, U_i] \\
      0, & \text{其他情况}
    \end{cases}
    \end{equation}
   其中 $L_i$ 和 $U_i$ 为第 $i$ 个变量的定义域上下限，删除条件为1表示需要删去该数据。
   \item 统计离群检测。对通过物理筛选后的数据计算均值 $\mu$ 和标准差 $\sigma$，构建离群点判定准则：
   \begin{equation}
       \text{离群阈值} = \mu \pm 3\sigma
   \end{equation}
   超出该范围的数据点视为离群点。具体步骤为：
   \begin{equation}
          \mu = \frac{1}{n}\sum_{i=1}^n x_i, \quad \sigma = \sqrt{\frac{1}{n-1}\sum_{i=1}^n (x_i - \mu)^2}
   \end{equation}

\end{enumerate}
首先根据各项数据的物理意义进行筛选，删除其中超出定义域的数据项。然后，删除超出数据中超过3倍标准差的离群数据。

数据导入和导出用于保存数据处理时的ROI信息。在一次FRET双杂交分析数据处理后，需要记录本次数据处理的处理数据，方便后续查看。导出的数据信息包括：

数据追踪是指在数据表格中点击某一条数据，软件会根据这条数据的位置和形状信息，在图像显示上显示该条数据对应的ROI位置，以方便识别数据中潜在的错误。实现这一功能，主要基于Qt提供的信号与槽机制。将数据中的数据模型被单机的事件与FretGraphicsView控件绑定后，FretGraphicView模型可以接收到来自所选数据的信息，并将当前活动的ROI按照所选数据的位置和形状重新绘制。

\subsection{结果可视化模块}
\ifshowtext
FRET双杂交分析的数据结果包括FRET数据进行双杂交计算的参数结果和拟合曲线图。
FRET双杂交分析数据拟合结果的参数是用户得到的核心结果，其中$n_D/n_A$、$K_{d,EFF}$等参数是生物学家最关心的生物大分子之间相互作用的参数。
FRET双杂交分析的拟合曲线图是将双杂交拟合曲线和实验采集到的散点同时绘制在一张图上，用于评估双杂交计算结果的拟合效果，以进一步判断FRET双杂交分析结果的可信度。

点击“保存结果”按钮后，上述数据结果和图片结果都将被保存，还将保存可在其他绘图软件上制图的原始数据，其中相比较圈点的数据来说，主要新增了$A_{free}$和$D_{free}$数据点，这部分信息的计算依赖于FRET双杂交分析的参数结果，在结果展示时才能确定。

结果可视化模块的界面主要包括三个部分：FRET双杂交分析算法选择；FRET双杂交分析图表结果；结果保存按钮。
\fi

\subsection{FRET双杂交计算模块}
FRET双杂交计算模块是对采集到FRET批数据$E_D$、$E_A$、$R_C$、$A_{est}$和$D_{est}$等数据进行最优化计算，以求取使得预测结果和测量结果之间误差最小时的关键参数。这部分模块主要封装了进行FRET双杂交计算时需要的优化算法库等。

（1）\textbf{DC-FRET线性拟合算法的封装}。根据公式\ref{eq:ea_appro}和\ref{eq:ed_appro}，DC-FRET拟合斜率时截距项为0，假设拟合的线性方程形式为
\begin{equation}
    E_D = E_{A,max}\cdot R_C,
\end{equation}
其中，$E_D$是自变量，$R_C$是自变量，$E_{A,max}$是斜率。线性拟合的目标是找到合适的参数$E_{A,max}$，使得方程预测的$E_D$值与实际观测到的$E_D$值之间的误差尽可能小。
通常使用最小二乘法，其原理是最小化观测值与预测值之间的误差平方和，即
\begin{equation}
    S=\sum^{n}_{i=1}(E_{D_i}-(E_{A,max}R_{C_i}))^2
\end{equation}
其中，$n$是数据点的数量，$R_{C_i}$和$E_{D_i}$分别是第i个数据点的自变量和因变量的值。
为了找到$S$最小的$E_{A,max}$值，对$S$关于$E_{A,max}$求偏导，并另其等于0。
首先，展开误差$S$：
\begin{align}
     S=\sum_{i = 1}^{n}(E_{D_i}^{2}-2E_{A,max}R_{C_i}E_{D_i} + E_{A,max}^{2}R_{C_i}^{2}), \\
     \frac{\partial S}{\partial E_{A,max}}=\sum_{i = 1}^{n}(-2R_{C_i}E_{D_i} + 2E_{A,max}R_{C_i}^{2}),
\end{align}
令 \(\frac{\partial S}{\partial E_{A,max}}=0\)：
\begin{align}
     \sum_{i = 1}^{n}(-2R_{C_i}E_{D_i} + 2E_{A,max}R_{C_i}^{2}) = 0, \\
    -2\sum_{i = 1}^{n}R_{C_i}E_{D_i}+2E_{A,max}\sum_{i = 1}^{n}R_{C_i}^{2}=0,
\end{align}
最后求解$E_{A,max}$：
\begin{equation}
       E_{A,max}=\frac{\sum_{i = 1}^{n}R_{C_i}E_{D_i}}{\sum_{i = 1}^{n}R_{C_i}^{2}}. \label{eq:linear_fit_quick}
\end{equation}
公式\ref{eq:linear_fit_quick}可用于直接求解斜率$E_{A,max}$和$E_{D,max}$，从而避免了基于迭代的线性拟合求解算法的消耗。

(2) Langmiur模型拟合算法的封装。Langmiur模型具有模型的非线性和参数的复杂性，无法通过简单的解析式解析其求解公式。因此，我们引入基于dlib计算库的双杂交系统参数拟合。

首先，基于dlib定义了用于拟合的数据类型ColumnVector类型。此类型用于存储双精度浮点数的列向量，在后续的计算和优化过程中承载参数向量和中间计算结果。
定义ExperimentalData结构体用于整合实验数据。
该结构体包含四个std::vector<double>类型的成员变量：aest存储与变量a相关的估计值序列，dest存储与变量d相关的估计值序列，ea\_corr存储变量a的相关误差序列，ed\_corr存储变量d的相关误差序列。这种数据结构的设计便于在不同函数间传递和处理实验数据，提高代码的模块化和可读性。

\begin{lstlisting}[language=C++, caption={基于dlib的FRET双杂交求解器代码片段}]
#include <iostream>
#include <vector>
#include <cmath>
#include <dlib/optimization.h>

// 定义列向量类型
typedef dlib::matrix<double, 0, 1> ColumnVector;

// 定义数据结构体，用于存储实验数据
struct ExperimentalData {
    std::vector<double> aest;
    std::vector<double> dest;
    std::vector<double> ea_corr;
    std::vector<double> ed_corr;
};
\end{lstlisting}

CalculateError函数用于计算单个数据点的误差。其数学定义为$Error(x, y) = (x - y)^2$，通过将输入值$x$和$y$进行平方差求和运算，返回误差值。此函数基于最小二乘法原理，将误差的平方作为衡量预测值与真实值偏离程度的指标，在后续的损失函数计算中被广泛应用。
CalculateLoss函数负责计算模型在整个数据集上的整体损失。对于给定的ExperimentalData实例data和参数向量parameters。


ObjectiveFunction函数是优化过程的目标函数。它接受参数向量parameters和指向ExperimentalData结构体的指针data\_ptr作为输入。函数内部将指针转换为ExperimentalData类型，然后调用CalculateLoss函数，以计算并返回基于当前参数和实验数据的损失值。该目标函数为优化算法提供了评估参数优劣的标准，优化算法通过不断调整参数来最小化该目标函数的值。

\begin{lstlisting}[language=C++, caption={基于dlib的FRET双杂交求解器代码片段}]
// 计算误差
double CalculateError(double x, double y) {
    return (x - y) * (x - y);
}

// 计算整体损失
double CalculateLoss(const ExperimentalData& data, const ColumnVector& parameters) {
    double total_error = 0.0;
    for (size_t i = 0; i < data.aest.size(); ++i) {
        double d_free = ((data.dest[i] - parameters(0) - data.aest[i] * parameters(1)) +
                         std::sqrt(std::pow(data.dest[i] - parameters(0) - data.aest[i] * parameters(1), 2) +
                                   4 * parameters(0) * data.dest[i])) / 2;
        double a_free = data.aest[i] - (data.dest[i] - d_free) / parameters(1);
        double ea_pred = parameters(2) * d_free / (d_free + parameters(0));
        double ed_pred = parameters(3) * a_free / (a_free + parameters(0) / parameters(1));

        total_error += CalculateError(data.ea_corr[i], ea_pred) + CalculateError(data.ed_corr[i], ed_pred);
    }
    return total_error;
}

// 目标函数，用于优化过程
double ObjectiveFunction(const ColumnVector& parameters, void* data_ptr) {
    auto data = static_cast<ExperimentalData*>(data_ptr);
    return CalculateLoss(*data, parameters);
}
\end{lstlisting}

TwoHybridSolver函数实现了整个参数拟合的优化过程，并对外提供调用接口。它接受四组实验数据向量aest\_data、dest\_data、ea\_corr\_data和ed\_corr\_data作为输入。
首先初始化优化的起始点starting\_point为一个包含四个元素的列向量$[1, 1, 0.5, 0.5]$，分别对应为$K_{d,EFF}$、$n_D/n_A$、$E_{A，max}$、$E_{D,max}$的初始值，这个起始点的初始值基于实际物理意义的先验知识，虽然它可能不是最优解，但为优化算法提供了一个初始起点。
接着创建ExperimentalData结构体实例，并使用输入的四组数据向量进行初始化。这一步确保了实验数据能够被正确地整合和传递给后续的计算函数。
然后在try - catch块中进行优化操作。在try块内，定义了目标函数包装器objective\_wrapper，它通过捕获外部的data变量，调用ObjectiveFunction函数，为优化算法提供了一个可调用的目标函数对象。
随后使用dlib库的find\_min\_using\_approximate\_derivatives函数进行优化。该函数采用bfgs\_search\_strategy搜索策略，该策略在优化过程中通过近似计算目标函数的梯度来确定搜索方向，具有收敛速度较快的优点；同时使用objective\_delta\_stop\_strategy停止策略，当目标函数值的变化小于指定阈值（这里为$10^{-7}$）时，认为优化过程已收敛，停止迭代。优化过程的目标函数为objective\_wrapper，起始点为之前初始化的starting\_point。
如果在优化过程中捕获到异常，catch块将在标准错误流中输出错误信息，便于调试和排查问题。

% 以下是代码展示部分
\begin{lstlisting}[language=C++, caption={基于dlib的FRET双杂交求解器代码片段}]
// 双杂交求解器，进行参数拟合
ColumnVector TwoHybridSolver(const std::vector<double>& aest_data,
                             const std::vector<double>& dest_data,
                             const std::vector<double>& ea_corr_data,
                             const std::vector<double>& ed_corr_data) {
    // 初始化起始点
    ColumnVector starting_point(4);
    starting_point = 1, 1, 0.5, 0.5;

    // 创建数据结构体
    ExperimentalData data = {aest_data, dest_data, ea_corr_data, ed_corr_data};

    try {
        // 定义目标函数包装器
        auto objective_wrapper = [&data](const ColumnVector& parameters) {
            return ObjectiveFunction(parameters, &data);
        };

        // 使用 dlib 进行优化
        dlib::find_min_using_approximate_derivatives(
            dlib::bfgs_search_strategy(),
            dlib::objective_delta_stop_strategy(1e-7),
            objective_wrapper,
            starting_point,
            -1,
            0.01);
    } catch (const std::exception& e) {
        std::cerr << "Optimization error: " << e.what() << std::endl;
    }

    return starting_point;
}
\end{lstlisting}




\section{本章小结}

\ifshowtext
本章介绍了FRET双杂交分析数据处理软件（Fretha）的设计和开发。Fretha采用分层架构设计，被分为表示层、业务层、数据访问层和数据层，从设计上尽可能地进行解耦，减少了冗余设计。基于FRET双杂交分析数据处理的需求，Fretha在功能逻辑上划分为成像参数设置模块、数据校验模块、FRET图像处理模块、数据控制模块和结果可视化模块，然后通过分层架构完成了每个功能模块的开发。得益于分层架构设计和功能模块化设计，Fretha实现了各种复杂Fretha说明Fretha是一款拥有用户友好界面、简单易用、处理高效的科研数据处理软件。
\fi